==AMF serialization/deserialization library==

'''AMF (Action Message Format)''' is native data serialization format for flash player. It is an effective way to exchange data between flash client and server.

More details about AMF can be found here http://en.wikipedia.org/wiki/Action_Message_Format

----
 
'''AMF (Action Message Format)''' -- это нативная сериализация/десериализация данных для флэш плеера. Используется им как для обмена данными с сервером, так и для хранения данных (в SharedObjects). В отличие от текстовых форматов сериализации (JSON, XML) обеспечивает компактное сжатие, следовательно меньший траффик и следовательно большую скорость передачи данных.

'''scala-amf-lib''' -- компактная библиотека, которая занимается только сериализацией/десериализацией и ничем больше. Она может быть использована независимо от протокола передачи данных (HTTP, TCP сокет) и служить основой для библиотек более высокого уровня.

'''scala-amf-mina-filters''' -- библиотека, предоставляющая фильтры для фрейморка [http://mina.apache.org/ Apache MINA]

С помощью Apache MINA, scala-amf-mina-filters и scala-amf-lib можно сделать быстрый и эффективный TCP сервер для флэш клиентов.

'''scala-rpc''' -- Remote Procedure Call модуль, работающий поверх scala-amf-lib и scala-amf-mina-filters

Модули '''sample-client''' и '''sample-server''' демонстрируют, как можно построить сервер на базе вышеупомянутых библиотек.

'''flash-lab''' нужен исключительно для того, чтобы смотреть, как сериализует данные флэш плеер. Так что в нем нет ничего интересного.

Библиотеки написаны на Scala, но совместимы с Java, и могут использоваться (и используются) в Java проекте.


===Sample client & server===

Модули '''sample-client''' и '''sample-server''' реализуют простую миниигру. 

Флэш клиент соединяется с сервером и получает от него цвет, которым этот клиент будет рисовать круги. Для каждого клиента генерируется свой цвет. 

О каждом новом круге, нарисованном клиентом, информация посылается на сервер, а сервер рассылает ее всем остальным клиентам. И они тоже рисуют этот круг нужным цветом. Таким образом все нарисованные круги синхронизируются между всеми клиентами.

Если очередной клиент присоеденится позже, когда уже нарисовано сколько-то кругов, то новый клиент получает информацию о всех этих кругах (историю) и тоже отображает их.

Ну и все. Этого достаточно, чтобы показать все способы взаимодействия клиента с сервером:
* клиент вызывает метод на сервере, передает данные, и получает ответ;
* клиент вызывает метод на сервере и не требует ответа;
* сервер вызывает метод на клиенте и передает данные;

показать базовую логику клиента:
* установить соединение;
* посылать запросы на сервер, обрабатывать ответ;
* принимать активные вызовы с сервера;

и базовую логику сервера:
* запуститься на нужном порту;
* принимать соединения;
* хранить список клиентов;
* принимать запросы клиентов и отвечать на них;
* активно посылать данные клиенту;
* обрабатывать дисконнект клиента;


===Ограничения AMF сериализации===

Реализация пока не полная. А может она и не будет полной, потому как мне полная вроде бы не нужна :) Делалось все для конкретного проекта, где передавались только примитивные типы и Object со стороны клиента; Map&lt;String, Objec&gt; со стороны сервера. Так сложилось по историческим причинам, ибо проект изначально был написан под Wowza, где передача более сложных типов не поддерживается.

Со стороны клиента можно передать объект любого типа, но на сервере будет получен Map&lt;String, Object&gt;. Поддержка '''registerClassAlias''' и сопоставление классов на клиенте и на сервере планируется в версии 2. 

Не поддерживаются: ByteArray, XmlDoc, Xml и IExternalizeAble. Поддержка таких данных не планируется. 

